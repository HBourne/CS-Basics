## C++ Interview Questions

#### 1. template在什么情况下使用
当代码功能相同，仅类型不同的时候，会使用template使代码整体更加简洁易读

#### 2. template有什么不好的地方
- 具体的数据类型只有在编译时才能确定
- 很难debug

#### 3. operator overload是什么， 为什么只有C++有，别的语言不实现
重新定义运算符的用法，一般作为成员函数定义，方便特定类的运算操作。运算符重载会导致代码有时不易读，造成误解。

不能被重载的运算符：: .* . ?

#### 4. 虚函数是什么，compile的时候对虚函数进行了什么操作，能否在compile的时候就决定使用的是哪个子类的实现？
虚函数指针的赋值在编译阶段完成。不能。

#### 5. 虚函数表放在哪里？虚表指针什么时候初始化？
放在对应object的头/尾，一般在全局变量块中。

如果没有继承：在构造函数执行初始化列表之前初始化虚标指针

如果有继承：在base class构造完之后，初始化子类的虚标指针

#### 5. 什么情况下需要自己定义类的析构函数(deconstructor)
当类当中的某个成员变量是别的对象的指针，而且这个指针是在当前类中在堆中开辟的空间创建的，而且并没有在操作中涉及到这个指针的delete操作，那么就需要自己写析构函数，在析构函数中手动delete，防止内存泄漏。

#### 6. C++多态原理
- 当类中存在虚函数时，编译器会在类中自动生成一个虚函数表
- 虚函数表是一个存储类成员函数指针的数据结构
- 虚函数表由编译器自动生成和维护
- virtual修饰的成员函数会被编译器放入虚函数表中
- 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针

#### 7. 什么时候需要用到拷贝构造函数
如果类的成员变量中有指针，并且有动态内存分配，则必须拥有一个拷贝构造函数

#### 8. static的作用以及static的生命周期&作用范围


#### 9. static成员变量和static成员函数


#### 10. malloc和new的区别
| Feature | new/delete | malloc/free |
| :---: | :---: | :---: |
| 分配内存的位置 | 自由存储区 | 堆 |
| 内存分配成功的返还值 | 完整类型指针 | void* |
| 内存分配失败的返还值 | 默认抛出异常 | NULL |
| 分配内存的大小 | 由编译器根据类型计算 | 必须显式指定字节数 |
| 已分配内存扩容 | 无法直观处理 | 使用realloc |
| 是否可以互相调用 | 可以 | 不可以 |
| 构造函数与析构函数 | 调用 | 不调用 |

#### 11. map的底层实现是什么
红黑树。优点是空间要求低，但是在时间复杂度上不如哈希表。

#### 12. 堆和栈的区别
| Feature | 堆 | 栈 |
| :---: | :---: | :---: |
| 空间释放 | 手动 | 自动 |
| 地址分配 | 由低到高 | 由高到低 |
| 分配效率 | 手动申请 | 系统申请 |
| 大小 | 很大（虚拟内存大小） | 较小（linux默认10MB） |
| 调用效率 | 慢 | 快 |
| 运行时/编译时分配 | 编译时 | 运行时 |
| 存放内容 | 程序员定义 | 函数返回地址、局部变量、寄存器内容等 |

#### 13. 简单介绍STL，vector扩容原理
C++内置的基础模板集合，包含了各种常用的存储数据的模板类型以及相应的操作函数

组成部分：
- 空间管理器：提供内存申请和释放功能
- 迭代器
- 适配器：将自己与另一个对象绑定，使得适配器对象的操作转换为对被绑定对象的操作
- 容器
- 算法

标准容器：
- 顺序容器：vector, list, deque
- 排序容器：set, multiset, map, multimap
- 哈希容器：hash_set, hash_multiset, hash_map

当容器的容量不够容纳数据时触发扩容，申请一块更大的内存地址，一般扩容因子为1.5或者2

#### 14. .c、.h和.o的区别
.c：源文件，所有变量和函数的定义，告诉计算机如何实现程序

.h：只做声明，编译后不产生代码，目的是为了实现软件的模块化

.o：编译后文件

#### 15. const


#### 16. 红黑树


<!-- #### 17.  -->


<!-- #### 18.  -->