## C++ Interview Questions

#### 1. template在什么情况下使用
当代码功能相同，仅类型不同的时候，会使用template使代码整体更加简洁易读

#### 2. template有什么不好的地方
- 具体的数据类型只有在编译时才能确定
- 很难debug

#### 3. operator overload是什么， 为什么只有C++有，别的语言不实现
重新定义运算符的用法，一般作为成员函数定义，方便特定类的运算操作。运算符重载会导致代码有时不易读，造成误解。

不能被重载的运算符：: .* . ?

#### 4. 虚函数是什么，compile的时候对虚函数进行了什么操作，能否在compile的时候就决定使用的是哪个子类的实现？
虚函数指针的赋值在编译阶段完成。不能。

#### 5. 虚函数表放在哪里？虚表指针什么时候初始化？
放在对应object的头/尾，一般在全局变量块中。

如果没有继承：在构造函数执行初始化列表之前初始化虚标指针

如果有继承：在base class构造完之后，初始化子类的虚标指针

#### 5. 什么情况下需要自己定义类的析构函数(deconstructor)
当类当中的某个成员变量是别的对象的指针，而且这个指针是在当前类中在堆中开辟的空间创建的，而且并没有在操作中涉及到这个指针的delete操作，那么就需要自己写析构函数，在析构函数中手动delete，防止内存泄漏。

#### 6. C++多态原理
- 当类中存在虚函数时，编译器会在类中自动生成一个虚函数表
- 虚函数表是一个存储类成员函数指针的数据结构
- 虚函数表由编译器自动生成和维护
- virtual修饰的成员函数会被编译器放入虚函数表中
- 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针

#### 7. 什么时候需要用到拷贝构造函数
如果类的成员变量中有指针，并且有动态内存分配，则必须拥有一个拷贝构造函数

#### 8. static的作用以及static的生命周期&作用范围
一般在为某个类（而不是某个对象）服务时使用，作用范围一般在类内部，要求static成员隐藏在类的内部，对外不可见。存储在全局变量块。

#### 9. static成员变量和static成员函数
- static成员函数
    - 属于整个类而非类的对象
    - 仅能访问类的静态数据和静态成员函数
    - 不能被定义为虚函数
- static成员变量
    - 可以节省内存，因为是所有该类的对象共有的
    - 如果需要防止父类静态变量的影响，可以在子类里定义同名的静态变量，编译器采用了name-mangling生成唯一标识，防止父子类中同名的变量混淆

#### 10. malloc和new的区别
| Feature | new/delete | malloc/free |
| :---: | :---: | :---: |
| 分配内存的位置 | 自由存储区 | 堆 |
| 内存分配成功的返还值 | 完整类型指针 | void* |
| 内存分配失败的返还值 | 默认抛出异常 | NULL |
| 分配内存的大小 | 由编译器根据类型计算 | 必须显式指定字节数 |
| 已分配内存扩容 | 无法直观处理 | 使用realloc |
| 是否可以互相调用 | 可以 | 不可以 |
| 构造函数与析构函数 | 调用 | 不调用 |

#### 11. override和overload
- overload：根据函数签名的不同，如输入变量个数，提供不同的函数定义，在编译时完成
- override：继承时发生，函数签名必须一致，运行时完成

#### 12. 堆和栈的区别
| Feature | 堆 | 栈 |
| :---: | :---: | :---: |
| 空间释放 | 手动 | 自动 |
| 地址分配 | 由低到高 | 由高到低 |
| 分配效率 | 手动申请 | 系统申请 |
| 大小 | 很大（虚拟内存大小） | 较小（linux默认10MB） |
| 调用效率 | 慢 | 快 |
| 运行时/编译时分配 | 编译时 | 运行时 |
| 存放内容 | 程序员定义 | 函数返回地址、局部变量、寄存器内容等 |

#### 13. 简单介绍STL，vector扩容原理
C++内置的基础模板集合，包含了各种常用的存储数据的模板类型以及相应的操作函数

组成部分：
- 空间管理器：提供内存申请和释放功能
- 迭代器
- 适配器：将自己与另一个对象绑定，使得适配器对象的操作转换为对被绑定对象的操作
- 容器
- 算法

标准容器：
- 顺序容器：vector, list, deque
- 排序容器：set, multiset, map, multimap
- 哈希容器：hash_set, hash_multiset, hash_map

当容器的容量不够容纳数据时触发扩容，申请一块更大的内存地址，一般扩容因子为1.5或者2

#### 14. .c、.h和.o的区别
.c：源文件，所有变量和函数的定义，告诉计算机如何实现程序

.h：只做声明，编译后不产生代码，目的是为了实现软件的模块化

.o：编译后文件

#### 15. const
- 相比宏常量(Define)，const便于类型检查
- 防止被意外修改
- 可以方便进行变量调整和修改
- 节省空间，避免不必要的内存分配，在运行过程中只有一份拷贝(Define会存在多份)，因此效率也更高
- 在内存中的全局变量块，在编译时分配内存
- const修饰成员函数时
    - 被修饰的成员函数不能修改任何的成员变量(mutable修饰的变量除外)
    - const成员函数不能调用非const成员函数，因为非const成员函数可能会修改成员变量
- const修饰指针变量时
    - 只有一个const，如果const位于*左侧(const int *)，表示指针所指数据为常量，不能通过解引用修改数据，指针本身是变量，可以指向其他的内存单元
    - 只有一个const，如果const位于*右侧(int * const)，表示指针本身是常量，不能指向其他内存地址，指针所指向的数据可以通过解引用修改
    - 两个const(const int * const)，表示指针和指向的数据都不能被修改

#### 16. 红黑树
- 每个节点要么是黑色，要么是红色
- 根节点是黑色
- 每个叶子节点是黑色
- 每个红色节点的两个字节点一定是黑色
- 任意一个节点到每个叶子节点的路径都包含数量相同的黑色节点
- 没有一条路径会比其他路径长出两倍

#### 17. map的底层实现是什么
红黑树。优点是空间要求低，但是在时间复杂度上不如哈希表。旋转次数少，对于搜索、插入、删除较多的情况下更优。

#### 18. C++11新特性
- auto
- container and iterator
- lambda function: [](){}，方括号用来“捕捉”周围代码的变量
- nullptr
- rvalue reference
- move：左值是有变量名的object，右值是一个临时的没有名字的object，move是将左值引用强制转化为右值引用
- thread
- decltype

#### 19. enum
由用户定义的若干枚举常量的集合

#### 21. 智能指针
- unique_ptr：拥有独有对象所有权语义的智能指针
- shared_ptr：拥有共享对象所有权语义的智能指针，通过引用计数(reference count)实现共享，计数为0时释放资源
- weak_ptr：shared_ptr的弱引用，解决了两个shared_ptr相互引用，导致这两个指针的引用计数永远不会下降为0的死锁问题，weak_ptr不会增加对象的引用计数
- auto_ptr：在c++17中移除

#### 22. static_cast, dynamic_cast & const_cast
- static_cast
    - 向上转换（子类指针/引用转基类） & 向下转换（没有动态类型检查，不安全）
    - 基本数据类型转换
    - 把void指针转换成目标类型的指针（不安全）
    - 把任何类型的表达式转换成void类型
- dynamic_cast
    - 向上转换时，与static_cast效果一样
    - 向下转换时，dynamic_cast具有类型检查的功能，比static_cast要安全
- const_cast
    - 常量指针转化成非常量指针，并且仍然指向原来的对象
    - 常量引用被转换成非常量引用，并且仍然指向原来的对象
    - 常量对象被转换成非常量对象

#### 23. 纯虚函数
仅实现接口，完全不实现方法

#### 24. Abstract Class
含有至少一个纯虚函数的类

<!-- #### 25.  -->